### Solution
1. iterative <br />
è¿™é¢˜å’Œä¹‹å‰åšè¿‡çš„ä¸€é“nested tree expansionå¾ˆåƒï¼Œå¾—å…ˆè¿›åŽå‡ºï¼Œå€’ç€æ¥ã€‚è¦æ³¨æ„çš„ç‚¹æ˜¯ï¼Œæœ€åŽä¸€ä¸ªnode popå‡ºæ¥ä¹‹åŽï¼Œå¦‚æžœstackä»ç„¶æœ‰ï¼ˆè¦checkï¼‰ï¼Œnodeæ˜¯æŒ‡å‘stackä»æœ‰çš„æœ€åŽä¸€ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”è¿™ä¸ªå…ƒç´ å› ä¸ºè¿˜æ²¡æœ‰å¤„ç†ï¼Œä¸èƒ½è¢«popå‡ºæ¥ï¼Œè¦æ³¨æ„ï¼ï¼è®°å¾—cur.left=None
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root: return None
        stack = collections.deque([root])
        
        while stack:
            cur = stack.pop()
            if cur.right:
                stack.append(cur.right)
            if cur.left:
                stack.append(cur.left)
                
            if stack:
                cur.right = stack[-1]
            cur.left = None
        return root
```
level order traversal å’Œ preorder ä¸è¦æ··æŽ‰.ä¸¾ä¸ªðŸŒ° [1,2,5,3,4,null,6]ã€‚level order traversalæ˜¯125346, preorderæ˜¯123456
```
# level order traversal
while stack:
	cur = stack.popleft()
	if cur.left:
		stack.append(cur.left)
	if cur.right:
		stack.append(cur.right)

# preorder traversal
while stack:
	cur = stack.pop()
	if cur.right:
		stack.append(cur.right)
	if cur.left:
		stack.append(cur.left)
```
2. recursion
é¦–å…ˆrecursionï¼Œæˆ‘ä»¬åˆ†æ²»æ³•ï¼Œå°±æ˜¯å‡è®¾å·¦è¾¹å’Œå³è¾¹éƒ½å¤„ç†å¥½äº†ï¼Œç„¶åŽè¦å¯¹å·¦å’Œå³å¹²ä»€ä¹ˆã€‚å†å¤„ç†ä¸€ä¸‹base caseã€‚
linked liståªè¦çŸ¥é“å¤´å’Œå°¾æ˜¯ä»€ä¹ˆï¼Œæ‰€ä»¥è¿™é¢˜recursionï¼Œå…¶å®žå°±æ˜¯è¿”å›žå­linked listï¼Œç„¶åŽå‘Šè¯‰rootï¼Œå­linked listçš„å¤´å’Œå°¾æ˜¯ä»€ä¹ˆï¼Œè¿žèµ·æ¥å°±å¥½ã€‚è¿™é‡Œæœ‰å‡ ç§æƒ…å†µã€‚å¦‚æžœæ²¡æœ‰rootï¼Œè¿”å›ž[None, None]ã€‚å¦åˆ™å¦‚æžœæœ‰å·¦linked listï¼Œå°±è¦æŠŠå³è¾¹çš„å­˜èµ·æ¥ï¼ˆå¦åˆ™ä¼šä¸¢å¤±ï¼‰ã€‚ç„¶åŽroot.right = left[0], left[1] = right[0], root.left=Noneã€‚å› ä¸ºå‡è®¾å³è¾¹ä¹Ÿå¤„ç†å¥½äº†ï¼Œå¦‚æžœæœ‰å³è¾¹ï¼Œç›´æŽ¥è¿”å›ž[root, right[1]]ã€‚å¦‚æžœæ²¡æœ‰å³è¾¹ï¼Œleft[1]å°±æ˜¯æœ€åŽä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ž[root, left[1]]ã€‚å¦‚æžœå·¦å³éƒ½æ²¡æœ‰ï¼Œè¯´æ˜Žé“¾è¡¨åªæœ‰è‡ªå·±ä¸€ä¸ªï¼Œå°±è¿”å›ž[root, root].
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.dfs(root)
        
    def dfs(self, root):
        if not root:
            return [None, None]
        
        left = self.dfs(root.left)
        right = self.dfs(root.right)
        
        if left[1]:
            tmp = right[0]
            root.right = left[0]
            left[1].right = right[0]
            root.left = None
        
        # è¿™æ—¶å€™rightå·²ç»flatternå¥½äº†
        if right[1]:
            return [root, right[1]]
        
        # å¦‚æžœæ²¡æœ‰rightï¼Œå°±æ˜¯left[1]æ˜¯æœ€åŽä¸€ä¸ªèŠ‚ç‚¹
        if left[1]:
            return [root, left[1]]
        
        # å¦‚æžœä¸¤è¾¹éƒ½æ²¡æœ‰
        return [root, root]

```

### recap
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return None
        
        head, tail = self.dfs(root)
        return head
    
    def dfs(self, root):
        if not root:
            return [None, None]
        
        left = self.dfs(root.left)
        right = self.dfs(root.right)
        
        if left[1]:
            tmp = right[0]
            root.right = left[0]
            left[1].right = right[0]
            root.left = None
            
        if right[1]:
            return [root, right[1]]
        if left[1]:
            return [root, left[1]]
        return [root, root]
'''

            root
                    [begin, end](left)
                                [begin, end]
'''
```